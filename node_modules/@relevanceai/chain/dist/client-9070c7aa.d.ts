import { JSONSchema4 } from 'json-schema';
import { JSONSchema, FromSchema } from 'json-schema-to-ts';

/** eslint-disable */
/**
 *
 * DON'T EDIT THIS FILE MANUALLY.
 * IT IS GENERATED BY src/scripts/generate.ts
 *
 */
interface PromptCompletionInput {
    prompt: string;
    model?: "openai-gpt35" | "openai-gpt4" | "palm-chat-bison" | "palm-text-bison" | "anthropic-claude-instant-v1" | "anthropic-claude-v1";
    history?: {
        role: "user" | "ai";
        message: string;
    }[];
    system_prompt?: string;
    strip_linebreaks?: boolean;
    temperature?: number;
    validators?: ({
        type?: "regex";
        value?: {
            pattern: string;
            flags?: string;
            [k: string]: any | undefined;
        };
        [k: string]: any | undefined;
    } | {
        type?: "is_json";
        value?: any;
        [k: string]: any | undefined;
    } | {
        type?: "jsonschema";
        /**
         * A JSONSchema object. For example: {"type": "object", "properties": {"name": {"type": "string"}}}
         */
        value?: {
            [k: string]: any | undefined;
        };
        [k: string]: any | undefined;
    })[];
}
interface PromptCompletionOutput {
    answer: string;
    prompt: string;
    user_key_used: boolean;
    validation_history: {
        role: "user" | "ai";
        message: string;
    }[];
}
interface ApiCallInput {
    url: string;
    method: "GET" | "POST" | "PUT" | "HEAD" | "PATCH" | "DELETE" | "OPTIONS";
    headers?: {
        [k: string]: any | undefined;
    };
    body?: string | {
        [k: string]: any | undefined;
    };
    response_type?: "string" | "json" | "arrayBuffer" | "blob";
}
interface ApiCallOutput {
    response_body: any;
    status: number;
}
interface JsCodeTransformationInput {
    code: string;
}
interface JsCodeTransformationOutput {
    /**
     * Return value of provided code
     */
    transformed: {
        [k: string]: any | undefined;
    };
    /**
     * Duration of provided code in milliseconds
     */
    duration: number;
    [k: string]: any | undefined;
}
interface SearchInput {
    dataset_id: string;
    query: string;
    vector_field: string;
    /**
     * The model name to use.
     */
    model: "image_text" | "text_image" | "all-mpnet-base-v2" | "clip-vit-b-32-image" | "clip-vit-b-32-text" | "clip-vit-l-14-image" | "clip-vit-l-14-text" | "sentence-transformers" | "text-embedding-ada-002" | "cohere-small" | "cohere-large" | "cohere-multilingual-22-12";
    content_field?: string;
    page_size?: number;
}
interface SearchOutput {
    results: (string | {
        [k: string]: any | undefined;
    })[];
    [k: string]: any | undefined;
}
interface SearchArrayInput {
    array: any[];
    query: string;
    page_size?: number;
}
interface SearchArrayOutput {
    results: any[];
}
interface BulkUpdateInput {
    dataset_id: string;
    documents: any[];
    ingest_in_background?: boolean;
}
interface BulkUpdateOutput {
    /**
     * Number of successfully processed documents.
     */
    inserted: number;
    /**
     * Information about documents that were not processed successfully.
     */
    failed_documents: {
        /**
         * _id field of unprocessed document.
         */
        _id?: {
            [k: string]: any | undefined;
        };
        error?: {
            /**
             * http status code of individual document insertion operation.
             */
            status?: number;
            /**
             * body response of individual document insertion operation.
             */
            body?: string;
        };
        [k: string]: any | undefined;
    }[];
    [k: string]: any | undefined;
}
interface GenerateVectorEmbeddingInput {
    input: string;
    /**
     * The model name to use.
     */
    model: "image_text" | "text_image" | "all-mpnet-base-v2" | "clip-vit-b-32-image" | "clip-vit-b-32-text" | "clip-vit-l-14-image" | "clip-vit-l-14-text" | "sentence-transformers" | "text-embedding-ada-002" | "cohere-small" | "cohere-large" | "cohere-multilingual-22-12";
}
interface GenerateVectorEmbeddingOutput {
    vector: any[];
    [k: string]: any | undefined;
}
interface RedisSearchInput {
    index: string;
    query: string;
    vector_field: string;
    /**
     * The model name to use.
     */
    model: "image_text" | "text_image" | "all-mpnet-base-v2" | "clip-vit-b-32-image" | "clip-vit-b-32-text" | "clip-vit-l-14-image" | "clip-vit-l-14-text" | "sentence-transformers" | "text-embedding-ada-002" | "cohere-small" | "cohere-large" | "cohere-multilingual-22-12";
    page_size?: number;
}
interface RedisSearchOutput {
    results: any[];
    [k: string]: any | undefined;
}
interface RedisInsertInput {
    key: string;
    document: {
        [k: string]: any | undefined;
    };
    wait?: boolean;
}
interface RedisInsertOutput {
    inserted: number;
    [k: string]: any | undefined;
}
interface JoinArrayInput {
    array: string[];
    sep: string;
}
interface JoinArrayOutput {
    text: string;
}
interface PdfToTextInput {
    pdf_url: string;
    use_ocr?: boolean;
}
interface PdfToTextOutput {
    text: string;
    number_of_pages: number;
}
interface AudioToTextInput {
    audio_url: string;
}
interface AudioToTextOutput {
    text: string;
}
interface MarkdownInput {
    markdown: string;
}
interface MarkdownOutput {
    [k: string]: any | undefined;
}
interface ToJsonInput {
    text: string;
}
interface ToJsonOutput {
    output: any;
}
interface ExportToFileInput {
    data: {
        [k: string]: any | undefined;
    };
    extension?: string;
}
interface ExportToFileOutput {
    export_url: string;
}
interface ObjectKeyFilterInput {
    needle: any[] | string;
    haystack: {
        [k: string]: any | undefined;
    };
}
interface ObjectKeyFilterOutput {
    filtered: any;
}
interface RegexInput {
    regex: string;
    string: string;
}
interface RegexOutput {
    match: any;
    found?: boolean;
}
interface RunTransformationInput {
    transformation_id: string;
    params: {
        [k: string]: any | undefined;
    };
}
interface RunTransformationOutput {
    output: any;
}
interface RunChainInput {
    studio_id: string;
    project?: string;
    version?: string;
    params: {
        [k: string]: any | undefined;
    };
}
interface RunChainOutput$1 {
    output: {
        [k: string]: any | undefined;
    };
    state?: {
        [k: string]: any | undefined;
    };
    /**
     * Status of the workflow. Used for knowing when to send an email notification.
     */
    status: "complete" | "inprogress" | "failed" | "cancelled";
    errors: {
        body?: string;
        [k: string]: any | undefined;
    }[];
    cost?: number;
    credits_used?: {
        credits: number;
        name: string;
        num_units?: number;
        multiplier?: number;
    }[];
    executionTime: number;
}
interface TriggerWorkflowInput {
    workflow_id: string;
    dataset_id: string;
    params: {
        [k: string]: any | undefined;
    };
}
interface TriggerWorkflowOutput {
    job_id: string;
    [k: string]: any | undefined;
}
interface SplitTextInput {
    text: string;
    method: "tokens" | "separator";
    num_tokens?: number;
    sep?: string;
}
interface SplitTextOutput {
    chunks: string[];
    [k: string]: any | undefined;
}
interface CombineArrayInput {
    array?: any[];
    method?: "concat";
    [k: string]: any | undefined;
}
interface CombineArrayOutput {
    combined: any;
    [k: string]: any | undefined;
}
interface UploadFileS3Input {
    blob: any;
    extension?: string;
    [k: string]: any | undefined;
}
interface UploadFileS3Output {
    url: string;
    [k: string]: any | undefined;
}
/**
 * Base class for all abstractmodels
 *
 */
interface SerperGoogleSearchInput {
    search_query: string;
    [k: string]: any | undefined;
}
/**
 * Base class for all abstractmodels
 *
 */
interface SerperGoogleSearchOutput {
    peopleAlsoAsk: any[];
    relatedSearches: any[];
    organic: any[];
    [k: string]: any | undefined;
}
interface AnalyseImageInput {
    image_url: string;
    prompt: string;
}
interface AnalyseImageOutput {
    output: string;
}
interface TruncateTextInput {
    text: string | any[];
    num_tokens: number;
}
interface TruncateTextOutput {
    chunks: string | any[];
    [k: string]: any | undefined;
}
interface BrowserlessScrapeInput {
    website_url: string;
    element_selector?: any[];
}
interface BrowserlessScrapeOutput {
    output: {
        [k: string]: any | undefined;
    };
}
interface GetWebpageInput {
    website_url: string;
}
interface GetWebpageOutput {
    contents: string;
}
interface RunReactAgentInput {
    task: string;
    max_thoughts?: number;
}
interface RunReactAgentOutput {
    action_history: {
        status: "complete" | "failure";
        body: string;
    }[];
    /**
     * Chain of thought for understanding actions taken.
     */
    chain_of_thought: string;
    /**
     * The answer to the question.
     */
    answer: string;
}
type BuiltinTransformations = {
    prompt_completion: {
        input: PromptCompletionInput;
        output: PromptCompletionOutput;
    };
    api_call: {
        input: ApiCallInput;
        output: ApiCallOutput;
    };
    js_code_transformation: {
        input: JsCodeTransformationInput;
        output: JsCodeTransformationOutput;
    };
    search: {
        input: SearchInput;
        output: SearchOutput;
    };
    search_array: {
        input: SearchArrayInput;
        output: SearchArrayOutput;
    };
    bulk_update: {
        input: BulkUpdateInput;
        output: BulkUpdateOutput;
    };
    generate_vector_embedding: {
        input: GenerateVectorEmbeddingInput;
        output: GenerateVectorEmbeddingOutput;
    };
    redis_search: {
        input: RedisSearchInput;
        output: RedisSearchOutput;
    };
    redis_insert: {
        input: RedisInsertInput;
        output: RedisInsertOutput;
    };
    join_array: {
        input: JoinArrayInput;
        output: JoinArrayOutput;
    };
    pdf_to_text: {
        input: PdfToTextInput;
        output: PdfToTextOutput;
    };
    audio_to_text: {
        input: AudioToTextInput;
        output: AudioToTextOutput;
    };
    markdown: {
        input: MarkdownInput;
        output: MarkdownOutput;
    };
    to_json: {
        input: ToJsonInput;
        output: ToJsonOutput;
    };
    export_to_file: {
        input: ExportToFileInput;
        output: ExportToFileOutput;
    };
    object_key_filter: {
        input: ObjectKeyFilterInput;
        output: ObjectKeyFilterOutput;
    };
    regex: {
        input: RegexInput;
        output: RegexOutput;
    };
    run_transformation: {
        input: RunTransformationInput;
        output: RunTransformationOutput;
    };
    run_chain: {
        input: RunChainInput;
        output: RunChainOutput$1;
    };
    trigger_workflow: {
        input: TriggerWorkflowInput;
        output: TriggerWorkflowOutput;
    };
    split_text: {
        input: SplitTextInput;
        output: SplitTextOutput;
    };
    combine_array: {
        input: CombineArrayInput;
        output: CombineArrayOutput;
    };
    upload_file_s3: {
        input: UploadFileS3Input;
        output: UploadFileS3Output;
    };
    serper_google_search: {
        input: SerperGoogleSearchInput;
        output: SerperGoogleSearchOutput;
    };
    analyse_image: {
        input: AnalyseImageInput;
        output: AnalyseImageOutput;
    };
    truncate_text: {
        input: TruncateTextInput;
        output: TruncateTextOutput;
    };
    browserless_scrape: {
        input: BrowserlessScrapeInput;
        output: BrowserlessScrapeOutput;
    };
    get_webpage: {
        input: GetWebpageInput;
        output: GetWebpageOutput;
    };
    run_react_agent: {
        input: RunReactAgentInput;
        output: RunReactAgentOutput;
    };
};

type ChainConfig = {
    _id?: string;
    /** Unique ID for studio. This is different from a studio's share ID. */
    studio_id: string;
    /** Project ID */
    project?: string;
    /** JSONSchema object that user parameters will be validated against */
    params_schema: {
        properties: Record<string, ParamSchema>;
    };
    /** Version */
    version?: string;
    /** User description for the studio */
    description?: string;
    /** User title for the studio */
    title?: string;
    /** Everything under here isn't in LimitedChains */
    transformations: {
        steps: TransformationStep[];
        output?: Record<string, string> | null;
    };
    publicly_triggerable?: boolean;
    params?: Record<string, any>;
    public?: boolean;
    metrics?: {
        views: number;
        executions: number;
    };
    share_id?: string;
    tags?: Record<string, string>;
};
type ChainState = {
    params: Record<string, any>;
    steps: Record<string, {
        executionTime: number;
        output: Record<string, any>;
        skipped?: boolean;
        results?: Record<string, any>[];
        skippedItems?: Record<string, any>[];
    }>;
};
type SchemaMetadata = {
    content_type?: "long_text" | "short_text" | "file_url" | "code" | "llm_prompt" | "dataset_id" | "markdown" | "chain";
    min?: number;
    max?: number;
    accepted_file_types?: string[];
    advanced?: boolean;
    title?: string;
    description?: string;
    enum?: Record<"description" | "value", string>[];
    hidden?: Boolean;
    value_suggestion_chain?: {
        url: string;
        project_id: string;
        output_key: string;
    };
};
type ParamSchema = JSONSchema4 & {
    /**
     * The order in which the parameter should be displayed in the form.
     */
    order?: number;
    metadata?: SchemaMetadata;
    items?: JSONSchema4 & {
        type: string;
    };
};
type TransformationStepIfConditionValue = string | boolean | null;
type TransformationStep = {
    transformation: string;
    name: string;
    foreach?: string | any[];
    if?: TransformationStepIfConditionValue;
    output?: Record<string, string>;
    params: Record<string, any>;
};
type PartiallyOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type Prettify<TType> = TType extends any[] | Date ? TType : {
    [K in keyof TType]: TType[K];
};
type ParamsToTypedObject<T extends Record<string, ParamSchema>> = {
    [K in keyof T]: T[K] extends JSONSchema ? FromSchema<T[K]> : any;
};
/**
 * Add types for custom transformations.
 *
 * @example
 * ```ts
 * declare module "@relevanceai/chain" {
 *   interface CustomTransformationsMap {
 *     "my-custom-transformation": {
 *       input: {
 *         myCustomParam: string;
 *       };
 *       output: {
 *         myCustomOutput: string;
 *       };
 *     }
 *   }
 * }
 * ```
 */
interface CustomTransformationsMap {
}
type TransformationsMap = CustomTransformationsMap & BuiltinTransformations;
type TypedTransformationId = keyof TransformationsMap;
type AllowedTransformationId = LooseAutoComplete<TypedTransformationId>;
type TransformationDetails<TransformationId extends AllowedTransformationId> = TransformationId extends TypedTransformationId ? TransformationsMap[TransformationId] : {
    input: Record<string, any>;
    output: Record<string, any>;
};
type TransformationInput<TransformationId extends AllowedTransformationId> = TransformationDetails<TransformationId>["input"];
type TransformationOutput<TransformationId extends AllowedTransformationId> = TransformationDetails<TransformationId>["output"];
type LooseAutoComplete<T extends string> = T | (string & {});
type ChainRunnable = {
    run: (params: any) => Record<string, any>;
};
type InferChainInput<Chain extends ChainRunnable> = Parameters<Chain["run"]>[0];
type InferChainOutput<Chain extends ChainRunnable> = Awaited<ReturnType<Chain["run"]>>["output"];
type RunChainOptions<ReturnState extends boolean = boolean> = {
    return_state?: ReturnState;
    version?: string;
    params?: Record<string, any>;
    studio_id: string;
    studio_override?: PartiallyOptional<ChainConfig, "project">;
    state_override?: ChainState;
};
type RunChainOutput<ReturnState extends boolean = boolean, Output extends Record<string, any> = Record<string, any>> = {
    status: "complete" | "inprogress" | "failed" | "cancelled";
    output: Output;
    executionTime?: number;
    errors: {
        raw: string;
        body: string;
        stepName?: string;
    }[];
} & (ReturnState extends true ? {
    state: ChainState;
} : {
    state?: undefined;
});
type ArrayItem<T extends any[]> = T extends (infer U)[] ? U : never;

declare class Client {
    private region;
    private project;
    constructor(args: {
        region: string;
        project: string;
    });
    runChain<Chain extends ChainRunnable>(chainId: string, params: InferChainInput<Chain>): Promise<InferChainOutput<Chain>>;
    runChain<Params extends Record<string, Exclude<any, Function>>, Output extends Record<string, any>>(chainId: string, params: Params): Promise<Output>;
}
declare class RunChainError extends Error {
    errors: RunChainOutput["errors"];
    constructor(errors: RunChainOutput["errors"], message?: string);
}

export { AllowedTransformationId as A, ChainConfig as C, InferChainInput as I, JsCodeTransformationOutput as J, Prettify as P, RunChainOptions as R, TransformationInput as T, RunChainOutput as a, ParamSchema as b, ParamsToTypedObject as c, TransformationOutput as d, ArrayItem as e, ChainState as f, InferChainOutput as g, TransformationsMap as h, CustomTransformationsMap as i, Client as j, RunChainError as k };
