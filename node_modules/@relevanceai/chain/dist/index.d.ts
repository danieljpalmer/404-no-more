import { C as ChainConfig, R as RunChainOptions, P as Prettify, a as RunChainOutput, b as ParamSchema, c as ParamsToTypedObject, A as AllowedTransformationId, T as TransformationInput, d as TransformationOutput, J as JsCodeTransformationOutput, e as ArrayItem, f as ChainState } from './client-9070c7aa.js';
export { j as Client, i as CustomTransformations, I as InferChainInput, g as InferChainOutput, k as RunChainError, h as TransformationsMap } from './client-9070c7aa.js';
import 'json-schema';
import 'json-schema-to-ts';

declare const VARIABLE_INTERNAL: unique symbol;
interface VariableInternal {
    readonly [VARIABLE_INTERNAL]: {
        path: string;
    };
}
type Primitive = string | number | boolean;
type ObjectValuesToArrays<T> = T extends Array<any> ? T : T extends Primitive ? T : T extends Record<string, any> ? {
    [K in keyof T]: Array<ObjectValuesToArrays<T[K]>>;
} : T;
type Variable<T> = T extends Primitive ? T & VariableInternal : T extends Array<infer Item> ? Array<Variable<Item>> & {
    "*": ObjectValuesToArrays<Variable<Item>>;
} : T extends Record<string, any> ? {
    [K in keyof T]: Variable<T[K]>;
} : T & VariableInternal;
type UnwrapVariable<T> = T extends Variable<infer U> ? U : T extends Array<Variable<infer U>> ? U[] : T extends Record<string, any> ? {
    [K in keyof T]: UnwrapVariable<T[K]>;
} : T;

type APIAuthDetails = {
    project: string;
    region: string;
    apiKey: string;
};
declare class API {
    private authDetails;
    constructor(authDetails?: APIAuthDetails);
    private get token();
    private request;
    getChain(chainId: string, version?: string): Promise<ChainConfig>;
    runChain<Output extends Record<string, any>>(options: RunChainOptions<true>): Promise<Prettify<RunChainOutput<true, Output>>>;
    runChain<Output extends Record<string, any>>(options: RunChainOptions<false>): Promise<Prettify<RunChainOutput<false, Output>>>;
    saveChains(body: {
        updates: ChainConfig[];
        version?: string;
        partial_update?: boolean;
    }): Promise<any>;
    getChainsByIds(ids: string[]): Promise<ChainConfig[]>;
    shareChain(chainId: string): Promise<{
        share_link: string;
        share_id: string;
        region: string;
    }>;
    unshareChain(chainId: string, shareId: string): Promise<void>;
}

declare class Chain<ParamsDefinition extends Record<string, ParamSchema>, OutputDefinition extends Record<string, any>> {
    $RELEVANCE_CHAIN_BRAND: boolean;
    protected api: API;
    private chainId;
    private params;
    private steps;
    private output;
    private title;
    private description;
    private publiclyTriggerable;
    constructor(authDetails?: APIAuthDetails);
    setTitle(title: string): void;
    setDescription(description: string): void;
    setPubliclyTriggerable(value: boolean): void;
    defineParams<InnerParamsDefinition extends ParamsDefinition>(params: InnerParamsDefinition): Variable<Prettify<ParamsToTypedObject<InnerParamsDefinition>>>;
    /**
     * Add a step to your chain. You can call this multiple times to add
     * multiple steps to your chain.
     *
     * @returns A variable that references the output of the step.
     *
     * @example
     * const { prompt, answer } = step('prompt_completion', {
     *   prompt: 'Write a short story about dogs',
     * })
     */
    step<TransformationId extends AllowedTransformationId>(transformation: TransformationId, params: TransformationInput<TransformationId>): Variable<TransformationOutput<TransformationId>>;
    private runIfContext;
    runIf<Fn extends () => any>(condition: any | Variable<any>, fn: Fn): ReturnType<Fn>;
    code<CodeParams extends Record<string, Variable<any>>, Fn extends (params: UnwrapVariable<CodeParams>) => any>(params: CodeParams, fn: Fn): Omit<JsCodeTransformationOutput, "transformed"> & {
        transformed: Variable<ReturnType<Fn>>;
    };
    private foreachContext;
    /**
     * Run 1 step for each item in the array.
     *
     * Note: foreach for multiple steps at once is not supported at the moment.
     */
    foreach<Var extends any[] | Variable<any[]>, Fn extends (foreachData: {
        item: Variable<ArrayItem<UnwrapVariable<Var>>>;
        index: number;
    }) => ReturnType<(typeof Chain)["prototype"]["step"]>>(variable: Var, fn: Fn): Variable<Array<ReturnType<Fn>>>;
    defineOutput(output: OutputDefinition): void;
    toJSON(): ChainConfig;
    setChainId(chainId: string): void;
    getChainId(): string | null;
    run(params: ParamsToTypedObject<ParamsDefinition>): Promise<{
        status: "complete" | "inprogress" | "failed" | "cancelled";
        output: UnwrapVariable<OutputDefinition>;
        executionTime?: number;
        errors: {
            raw: string;
            body: string;
            stepName?: string;
        }[];
        state: ChainState;
    }>;
    static define: <ChainParamsDefinition extends Record<string, ParamSchema>, ChainOutputDefinition extends Record<string, any>>(input: {
        title?: string;
        description?: string;
        /**
         * If true, the chain will be publicly triggerable. This means that anyone
         * with the chain's ID will be able to run it and that you will be able to
         * run the chain via `client.runChain`.
         *
         */
        publiclyTriggerable?: boolean;
        /**
         * Schemas for the inputs to your chain. This is optional, but if provided,
         * we will check that the inputs to your chain are valid at runtime, and
         * you get autocomplete for the inputs to your chain.
         */
        params?: ChainParamsDefinition;
        /**
         * The setup function is where you define the steps of your chain. It is
         * called with an object containing the params and a `step` function. You
         * call `step` to add a step to your chain.
         *
         * You can return an object from the setup function, which will be used as
         * the output of your chain. If you don't return anything, the output of
         * your chain will be the output of the last step.
         */
        setup(context: {
            /**
             * The inputs to the chain.
             */
            params: Variable<Prettify<ParamsToTypedObject<ChainParamsDefinition>>>;
            step: (typeof Chain)["prototype"]["step"];
            runIf: (typeof Chain)["prototype"]["runIf"];
            code: (typeof Chain)["prototype"]["code"];
            foreach: (typeof Chain)["prototype"]["foreach"];
        }): void | ChainOutputDefinition | null;
    }) => Chain<ChainParamsDefinition, ChainOutputDefinition>;
}
/**
 * Define an AI chain. This is the main entry point for creating chains.
 */
declare const defineChain: (typeof Chain)["define"];

export { Chain, defineChain };
