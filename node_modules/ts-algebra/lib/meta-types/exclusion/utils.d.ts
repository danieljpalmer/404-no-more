import { And, Not } from "../../utils";
import { NeverType } from "../never";
import { Type } from "../type";
import { _$Exclude } from "./index";
export declare type CrossValue<V1 extends Type, P1 extends boolean, R1 extends boolean, V2 extends Type, P2 extends boolean, R2 extends boolean> = {
    originValue: V1;
    isPossibleInOrigin: P1;
    isRequiredInOrigin: R1;
    isPossibleInSubstracted: P2;
    isRequiredInSubstracted: R2;
    exclusionResult: _$Exclude<V1, V2>;
};
export declare type CrossValueType = {
    originValue: Type;
    isPossibleInOrigin: boolean;
    isRequiredInOrigin: boolean;
    isPossibleInSubstracted: boolean;
    isRequiredInSubstracted: boolean;
    exclusionResult: any;
};
export declare type OriginValue<C extends CrossValueType> = C["originValue"];
declare type IsPossibleInOrigin<C extends CrossValueType> = C["isPossibleInOrigin"];
declare type IsRequiredInOrigin<C extends CrossValueType> = C["isRequiredInOrigin"];
declare type IsPossibleInSubstracted<C extends CrossValueType> = C["isPossibleInSubstracted"];
declare type IsRequiredInSubstracted<C extends CrossValueType> = C["isRequiredInSubstracted"];
export declare type ExclusionResult<C extends CrossValueType> = C["exclusionResult"];
export declare type IsOutsideOfOriginScope<C extends CrossValueType> = And<IsRequiredInSubstracted<C>, Not<IsPossibleInOrigin<C>>>;
export declare type IsOutsideOfSubstractedScope<C extends CrossValueType> = And<IsRequiredInOrigin<C>, Not<IsPossibleInSubstracted<C>>>;
export declare type Propagate<C extends CrossValueType> = ExclusionResult<C> extends NeverType ? OriginValue<C> : ExclusionResult<C>;
export declare type IsOmittable<C extends CrossValueType> = And<Not<IsRequiredInOrigin<C>>, IsRequiredInSubstracted<C>>;
export {};
