import { DoesExtend, Not, And } from "../utils";
import { Never, NeverType } from "./never";
import { Type } from "./type";
import { Resolve, ResolveOptions } from "./resolve";
import { Deserialized, IsSerialized } from "./utils";
export declare type TupleTypeId = "tuple";
export declare type Tuple<V extends Type[], P extends Type = Never, I extends boolean = false, D extends unknown = never> = $Tuple<V, P, I, D>;
export declare type $Tuple<V, P = Never, I = false, D = never> = IsAnyValueNever<V> extends true ? Never : {
    type: TupleTypeId;
    values: V;
    isOpen: Not<DoesExtend<P, NeverType>>;
    openProps: P;
    isSerialized: I;
    deserialized: D;
};
declare type IsAnyValueNever<V> = V extends [infer H, ...infer T] ? H extends NeverType ? true : IsAnyValueNever<T> : false;
export declare type TupleType = {
    type: TupleTypeId;
    values: Type[];
    isOpen: boolean;
    openProps: Type;
    isSerialized: boolean;
    deserialized: unknown;
};
export declare type TupleValues<T extends TupleType> = T["values"];
export declare type IsTupleOpen<T extends TupleType> = T["isOpen"];
export declare type TupleOpenProps<T extends TupleType> = T["openProps"];
export declare type ResolveTuple<T extends TupleType, O extends ResolveOptions> = And<O["deserialize"], IsSerialized<T>> extends true ? Deserialized<T> : IsTupleOpen<T> extends true ? [...RecurseOnTuple<TupleValues<T>, O>, ...Resolve<TupleOpenProps<T>, O>[]] : RecurseOnTuple<TupleValues<T>, O>;
declare type RecurseOnTuple<V extends Type[], O extends ResolveOptions, R extends any[] = []> = V extends [infer H, ...infer T] ? H extends Type ? T extends Type[] ? RecurseOnTuple<T, O, [...R, Resolve<H, O>]> : never : never : R;
export {};
